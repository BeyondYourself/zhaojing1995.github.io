---
layout:     post
title:      深度学习 | 机器学习基础
subtitle:   大规模深度学习、计算机视觉、语音识别、自然语言处理
date:       2019-08-06
author:     JoselynZhao
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - Deep Learning
---


## 深度学习教程与实战案列系列文章
---------------
[深度学习 | 绪论](https://blog.csdn.net/NGUever15/article/details/89455808)
[深度学习 | 线性代数基础](https://blog.csdn.net/NGUever15/article/details/89326430)
[深度学习 | 机器学习基础](https://blog.csdn.net/NGUever15/article/details/98593687)
[深度学习 | 实践方法论](https://blog.csdn.net/NGUever15/article/details/98306066)
[深度学习 | 应用](https://blog.csdn.net/NGUever15/article/details/98506607)
[深度学习 | 安装conda、opencv、pycharm以及相关问题](https://blog.csdn.net/NGUever15/article/details/89481345)
[深度学习 | 工具及实践（TensorFlow）](https://blog.csdn.net/NGUever15/article/details/89681161)
[深度学习 | TensorFlow 命名机制和变量共享、变量赋值与模型封装](https://blog.csdn.net/NGUever15/article/details/90201631)
[深度学习 | TFSlim介绍](https://blog.csdn.net/NGUever15/article/details/90375144)
[深度学习 | TensorFlow可视化 ](https://blog.csdn.net/NGUever15/article/details/90732489)
[深度学习 | 训练及优化方法](https://blog.csdn.net/NGUever15/article/details/92655337)
[深度学习 | 模型评估与梯度下降优化](https://blog.csdn.net/NGUever15/article/details/92801931)
[深度学习 | 物体检测](https://blog.csdn.net/NGUever15/article/details/93488853)
[深度学习| 实战1-python基本操作]( https://blog.csdn.net/NGUever15/article/details/96321720)
[深度学习 | 实战2-TensorFlow基础]( https://blog.csdn.net/NGUever15/article/details/96323428)
[深度学习 | 实战3-设计变量共享网络进行MNIST分类]( https://blog.csdn.net/NGUever15/article/details/96326470)
[深度学习 | 实战4-将LENET封装为class，并进行分类 ](https://blog.csdn.net/NGUever15/article/details/96328937)
[深度学习 | 实战5-用slim 定义Lenet网络，并训练测试]( https://blog.csdn.net/NGUever15/article/details/96342112)
[深度学习 | 实战6-利用tensorboard实现卷积可视化]( https://blog.csdn.net/NGUever15/article/details/96343303)
[深度学习 | 实战7- 连体网络MINIST优化]( https://blog.csdn.net/NGUever15/article/details/96344682)
[深度学习 | 实战8 - 梯度截断]( https://blog.csdn.net/NGUever15/article/details/96345640)
[深度学习 | 实战9- 参数正则化]( https://blog.csdn.net/NGUever15/article/details/96357540)
     
-----------------


深度学习是机器学习的一个特定分支。
首先，我们将介绍学习算法的定义，并介绍一个简单的示例：**线性回归算法**。接下来，我们会探讨**拟合训练数据**和**寻找能够泛化到新数据的参数**有哪些不同。

机器学习本质上属于应用统计学，**更多关注于如何用计算机统计地估计复杂函数**，不太关注这些函数的置信区间；因此我们会探讨两种统计学的主要方法：**频率估计**和**贝叶斯推断。**

大部分深度学习算法都基于随机梯度下降求解。我们将介绍如何组合不同的算法部分，**例如优化算法、代价函数、模型和数据集，来建立一个机器学习算法。**

# 1 学习算法
机器学习算法是一种可以从数据中学习的算法。
## 1.1 任务，T

机器学习可以让我们解决一些人为设计和实现固定程序很难解决的问题。

**学习**是我们所谓的获取完成任务的能力。

通常**机器学习任务**定义为机器学习系统该如何处理**样本 (example)。**

**样本**是指我们从某些希望机器学习系统处理的对象或事件中收集到的**已经量化的特征** (feature)的集合。

我们通常会将样本表示成一个向量 x ∈ Rn，其中向量的每一个元素 xi 是一个特征。

**一些非常常见的机器学习任务列举如下：**

- **分类**。
在这类任务中，计算机程序需要指定某些输入属于 k 类中的哪一类。
为了完成这个任务，学习算法通常会返回一个函数 f : R^n^ → {1, . . . , k}。
当y = f(x) 时，模型为向量 x 所代表的输入指定数字码 y 所代表的类别。

- **输入缺失分类**。
当输入向量的**每个度量**不被保证的时候，分类问题将会更有挑战。
当一些输入可能丢失时，学习算法必须学习一组函数，而不是单个分类函数。每个函数对应着分类具有不同缺失输入子集的 x。
- **回归**
这类任务中，计算机程序会给定输入预测数值。
学习算法会输出函数 f : R^n^ → R。

- **转录**
这类任务中，机器学习系统观测一些相对非结构化表示的数据，并转录信息为离散的文本形式。
例如：根据文本图片返回文字序列、语音识别

- **机器翻译**
在机器翻译任务中，输入是一种语言的符号序列，计算机程序必须将其转化成另一种语言的符号序列。

- **结构化输出**
结构化输出任务涉及到输出是不同元素之间重要关系的向量（或者是含多个值的其他数据结构）的任务。包括上面转录任务和翻译任务在内的很多其他任务。
这类任务被称为结构化输出任务是因为输出值之间内部紧密相关。例如，图片标题程序输出的单词必须组合成一个通顺的句子。

- **异常检测**
计算机程序在一组事件或对象中筛选，并标记不正常或非典型的个体。
异常检测任务的一个例子是信用卡欺诈检测。

- **合成和采样**
机器学习程序生成一些和训练数据相似的新样本。
通过机器学习，合成和采样可能在媒体应用中非常有用，可以避免艺术家大量昂贵或者乏味费时的手动工作。

- **缺失值填补**
这类任务中，机器学习算法给定一个新样本x ∈ R^n^，x 中某些元素 xi 缺失。算法必须填补这些缺失值。

- **去噪**：
机器学习算法的输入是，由未知破坏过程从干净样本x ∈ R^n^得到的污染样本x˜ ∈ R^n^。算法根据污染后的样本x˜ 预测干净的样本x，或者更一般地预测条件概率分布 P(x | x˜)。

- **密度估计或概率分布律函数估计**
在密度估计问题中，机器学习算法学习函数pmodel : R^n^ → R，其中 pmodel(x) 可以解释成样本采样空间的概率密度函数（如果 x 是连续的）或者概率分布律函数（如果 x 是离散的）。
算法需要学习观测到的数据的结构。算法必须知道什么情下样本聚堆出现，什么情况下不太可能出现。

例如，如果我们通过密度估计得到了概率分布 p(x)，我们可以用该分布解决缺失值填补任务。

## 1.2 性能度量，P

为了评估机器学习算法的能力，我们必须设计其性能的定量度量。**通常性能度量P 是特定于系统执行的任务 T 而言的**。

对于诸如分类，缺失输入分类和转录任务，我们通常度量模型的准确率 (accuracy)。
**准确率**是指该模型输出正确结果的样本比例。
**错误率**是指该模型输出错误结果的样本比例。

我们通常把**错误率称作 0-1 损失的期望**。

对于密度估计这类任务而言，使模型对每个样本都输出一个连续数值的得分。最常用的方法是输出模型在一些样本上概率对数的平均值。

我们将训练机器学习系统的训练集数据中的一部分作为**测试集 (test set)** 数据评估系统性能。

**难点**：
- 度量什么？
- 度量哪些值？

## 1.3 经验，E
根据学习过程中的不同经验，机器学习算法可以大致分类为**无监督 (unsupervised)** 和**监督 (supervised)**。

**数据集**是指很多样本组成的集合，如第5.1.1节的定义。有时我们也将样本称为**数据
点 (data point)**。

**无监督学习算法 (unsupervised learning algorithm)** 训练含有很多特征的数据集，然后学习出这个**数据集上有用的结构性质**。

在深度学习中，我们通常要学习**生成数据集的整个概率分布**。
显式地，比如**密度估计**，
隐式地，比如**合成或去噪**。

**其他类型的无监督学习任务**
- 聚类，将数据集分成相似样本的集合。

**监督学习算法 (supervised learning algorithm)** 训练含有很多特征的数据集，不过数据集中的样本都有一个**标签 (label)** 或**目标 (target)**。

**总结**
无监督学习涉及到观察随机向量 x 的好几个样本，试图隐式或显式地学习出概率分布 p(x)，或者是该分布一些有意思的性质；
监督学习包含观察随机向量 x 及其相关联的值或向量 y，然后从 x 预测 y，通常是估计 p(y | x)。
> 估计在x的情况下，y的概率

传统地，人们将**回归，分类，或者结构化输出问题称为监督学习**。
支持其他任务的**密度估计通常被称为无监督学习**。


**半监督学习**中，一些样本有监督目标，但其他的没有。
在多实例学习中，样本的整个集合被标记为含有或者不含有该类的样本，但是集合中单独的样本是没有标记的。


**强化学习 (reinforcement learning**) 算法不是训练于一个固定的数据集上，会和环境进行交互，所以学习系统和它的训练过程会有反馈回路。

**数据集**都是样本的集合，而样本是特征的集合。

表示数据集的常用方法是**设计矩阵 (design matrix)**。设计矩阵的每一行包含一个不同的样本。每一列对应不同的特征。
当然，将一个数据集表示成设计矩阵，必须是可以将每一个样本表示成向量，并且这些**向量的大小相同。** 
在向量大小不同的情况下，我们不会将数据集表示成 m 行的矩阵，而是表示成 m 个元素的结合：{$x^{(1)},x^{(2)},...,x^{(m)},$}.这种表示方式并非意味着样本向量 x^(i)^ 和x^(j)^ 有相同的大小。

在监督学习中，样本包含一个标签或目标和一组特征。通常当工作在包含观测特征的设计矩阵X 的数据集时，我们也会提供一个标签向量 y，其中 yi 表示样本i的标签。

**总结**
监督学习和无监督学习没有正式的定义
数据集或者经验也没有严格的区分。

## 1.4 实例：线性回归
我们的目标是建立一个系统，将向量 x ∈ R^n^ 作为输入，预测标量 y ∈ R 作为输出。
线性回归的输出是其输入的线性函数。让 yˆ 表示模型预测 y 应该取的值。
我们定义输出为
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806111901161.png)
其中 w ∈ R^n^ 是参数 (parameter) 向量。 //特征的权重

度量模型性能的一种方法是计算模型在测试集上的均方误差 (mean squarerror)。
如果 yˆ(test) 表示模型在测试集上的预测值，那么均方误差表示为：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019080611213730.png)
直观上，当 yˆ(test) = y(test) 时，我们会发现误差降为 0。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019080615453513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806154703930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

通过式(5.12)给出解的系统方程被称为**正规方程 (normal equation)**。
截距项 b 通常被称为仿射变换的**偏置（bias）参数**。

# 2 容量、过拟合和欠拟合

**机器学习的主要挑战**是我们的算法必须能够在先前未观测的新输入上表现良好，而不只是在训练集上效果好。
在先前未观测到的输入上表现良好的能力被称为**泛 化 (generalization)**。
在训练集上计算一些度量误差，被称为**训练误差 (training error)**，并且我们会降低训练误差。
机器学习和优化不同的地方在于，我们也希望**泛化误差 (generalization error)**，也被称为**测试误差 (test error)**，很低。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806155130342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

**当我们只能观测到训练集时，我们如何才能影响测试集的性能呢？**
**统计学习理论 (statistical learning theory)** 提供了一些答案。

训练集和测试集数据通过数据集上被称为**数据生成过程 (data generating process)** 的概率分布生成。
我们会做一系列假设，被统称为**独立同分布假设 (i.i.d.assumption)**:
每个数据集中的样本都是彼此**相互独立的 (independent)**，并且训练集和测试集是**同分布的 (identically distributed)**，其上数据采样自相同的分布。

我们将这个共享的潜在分布称为**数据生成分布 (data generating distribution)**，记作 pdata。

我们能观察到训练误差和测试误差之间的**直接联系**是，随机模型训练误差的期望和该模型测试误差的**期望是一样**的。

**以下是决定机器学习算法效果是否好的因素：**
1. 降低训练误差
2. 缩小训练误差和测试误差的差距

这两个因素对应机器学习的**两个主要挑战**：**欠拟合 (underfitting) **和**过拟合 (overfitting)**。

欠拟合发生于模型不能在训练集上获得足够低的误差。
过拟合发生于训练误差和和测试误差之间的差距太大。

通过调整**模型的容量 (capacity)**，我们可以控制模型是否偏向于过拟合或者欠拟合。
**模型的容量是指其拟合各种函数的能力**  .
容量低的模型可能很难拟合训练集。
容量高的模型可能会过拟合，因为记住了不适用于测试集的训练集性质。

**一种控制训练算法容量的方法**是选择**假设空间 (hypothesis space**)，即能够选为解决方案的学习算法函数集。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806160132841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)
我们探讨了通过**改变输入特征的数目**，和**加入这些特征对应的参数**，改变模型的容量。

容量不仅取决于模型的选择。模型规定了调整参数降低训练对象时，学习算法可以从哪些函数族中选
择函数。这被称为**模型的表示容量 (representational capacity)**。
学习算法的**有效容量 (effective capacity)** 可能小于模型族的表示容量。

统计学习理论中最重要的结论阐述了**训练误差和泛化误差之间差异的上界随着模型容量增长而增长，但随着训练样本增多而下降**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806161035887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

从预先知道的真实分布 p(x, y) 预测而出现的误差被称为**贝叶斯误差 (Bayeserror)**。
任何模型容量小于最优容量的固定参数模型会渐近到大于贝叶斯误差的误差值。


VC维 

## 2.1 没有免费午餐定理
机器学习的**没有免费午餐定理 (nofree lunch theorem)** 表明，在所有可能的数据生成分布上平均，每一个分类算法在未事先观测的点上都有相同的错误率。
换言之，在某种意义上，没有一个机器学习算法总是比其他的要好。
这意味着机器学习研究的目标不是找一个通用学习算法或是绝对最好的学习算法。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190806161820892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)
在特定任务上设定 及其学习算法。


## 2.2 正则化
我们可以加入**权重衰减 (weight decay)** 来修改线性回归的训练标准。
正则化一个学习函数 f(x; θ) 的模型，我们可以给代价函数添加被称为**正则化项 (regularizer) 的惩罚**
表示对函数的偏好是比增减假设空间的成员函数更一般的去控制模型容量的方法。

有很多其他方法隐式地或显式地**表示对不同解决方法的偏好**。总而言之，这些不同的方法都被称为**正则化 (regularization)**。
**正则化是指我们对学习算法所做的降低泛化误差而非训练误差的修改。**
正则化是机器学习领域的中心问题之一，能够和其重要性媲美的只有优化。

没有免费午餐定理已经清楚阐述了**没有最优的学习算法，特别地，没有最优的正则化形式**
> 权重越小，模型的泛化能力越强。

正则化项为 $\lambda W^TW$, 其中λ 为超参数。
**λ 过大 欠拟合，λ 过小 则 过拟合。** 

# 3 超参数和验证集
## 超参数
定义： 无法通过学习算法本身学习。

## 验证集
定义： 从训练数据集中构建**验证集**， 用于评估训练中或训练后的泛化误差。

**常用方法：**
- 交叉验证
 K-折交叉验证。
 

# 4 估计、偏差和方差
 ## 点估计
 定义： 是m个独立同分布的数据点 的任意函数
## 偏差
定义：估计的偏差 bias  = 期望-真实值

## 方差和标准差
方差刻画数据的离散程度
公式
公式
算法 A 比 算法B好： A的误差的95% 的置信上届，……

## 均方误差
用于度量模型的泛化误差

## 一致性
如果数据中 的数量m增加时，点估计收敛到对应参数的真实值。

# 5 最大似然估计

。。。
# 6 贝叶斯统计
## 主要思想
用概率反映状态的确定程度
真实参数是一个随机变量
将真实参数的已知知识表示为先验概率分布P。 一般会设定得宽泛一些。

## 贝叶斯规则
## 贝叶斯估计和最大似然估计的区别

最大似然估计 使用 参数的点估计
贝叶斯是使用参数的全分布。

基于前面观察的数据点，预测下一个。

## 最大后验MAP估计
贝叶斯估计需要积分，而后验估计 是 对数似然项 和先验分布的和

# 7 监督学习算法
基本思想： 学习关联输入x和输出y
支持向量机 SVM
K-最近邻算法 KNN：根据在特征空间的具体分布来确定类别
决策树算法：

# 8 无监督学习算法
不要人为标注，从分布中采样和去燥，对样本进行聚类。
找到数据的最佳表示，比原始数据更简单，更易访问，尽可能地保留更多的信息。

简单的表示：
- 低维表示 ：低依赖，消除冗余
- 稀疏表示 
- 独立表示：分开表示的来源

主成分分析 PCA：
- 降维，压缩数据。
- 输出比原始输入更低维度的表示。
- $z = W^T x$ 将输入x 投影表示成z，将二维输入变成一维输出
- 输出元素之间彼此线性无关的表示
- 可以根据奇异值分解SVD 来获得 $X= U \sum W^T$
- $$X^TX = W \sum  ^2 W^T$$
- 输出元素之间彼此线性无关的表示

K-均值聚类
- 将训练集分成k个靠近彼此的不同样本的聚类。
- 初始化k个中心点。
- 根据k个中心点 来划分分类，再根据分类的区域重新计算中心点。
-  聚类的效果好坏不好衡量。
- 聚类标准模糊

# 9 随机梯度下降
基本思想： 每次小批量样本计算梯度，时间复杂度低。
# 10 构建机器学习算法
算法组成：
- 特定的数据集
- 代价函数：
	- 交叉熵
	- 正则化
- 优化过程
	- 闭解优化
	- 迭代数值优化
- 模型
# 11 推动深度学习的挑战
泛化能力不足
- 维数灾难
- 局部不变性和平滑正则化
- 流形学习： 连接在一起的区域
从高位采样中 找打低维流形，从而实现降维。


